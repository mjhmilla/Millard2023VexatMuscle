function [forceLengthProximalTitinCurve, forceLengthProximalTitinInverseCurve,...
            forceLengthDistalTitinCurve, forceLengthDistalTitinInverseCurve,...
            forceLengthIgPTitinCurve, forceLengthIgPInverseTitinCurve,...
            forceLengthPevkTitinCurve, forceLengthPevkInverseTitinCurve,...
            forceLengthIgDTitinCurve, forceLengthIgDInverseTitinCurve] ...
          = createCandidateTitinCurves2025(fiberForceLengthCurve,...                                   
                                   forceLengthCurveSettings,...
                                   forceLengthECMHalfCurve,...
                                   sarcomereProperties,...
                                   muscleName,...
                                   flag_useWLCTitinModel,...                                   
                                   flag_createTwoSidedCurves,...
                                   flag_computeCurveIntegrals,...
                                   flag_useElasticIgD,...
                                   flag_activeTitinModel,...
                                   flag_useOctave)

%%
% Tuning variables
%%

pevkDefaultBlendingVariable = 1; %0 means remove all slack, 1 is accept default
igDefaultBlendingVariable   = 1;
scalePevkStretchRate        = 1;

scaleIgKLow                 = 2;
useBigIgKZero               = 0;

scalePevkKLow              = 2;
useBigPevkZero             = 0;

scalePKLow                 = 2;
useBigKPZero               = 0;

scaleDKLow                 = 2;
useBigKDZero               = 0;

figpZero = 0.00;
figdZero = 0.00;
fpevkZero= 0.00;
fPZero   = 0.00;
fDZero   = 0.00;

sarcomereProperties.PEVKNormStretchRate = ...
    sarcomereProperties.PEVKNormStretchRate*scalePevkStretchRate;

titinCurviness = 0.5;%forceLengthCurveSettings.curviness;

igCurviness = 0.5;%titinCurviness;
pevkCurviness = 0.5;%titinCurviness;




%%
%Evaluate the length and stiffness of fpe when it reaches a normalized
%force of 1.
%%

flag_solveForDefaultTwoSegmentTitinParameters=1;

lambdaECM = sarcomereProperties.extraCellularMatrixPassiveForceFraction;
normPevkToActinAttachmentPoint = sarcomereProperties.normPevkToActinAttachmentPoint;

%%
% Get the titin normalized segment lengths
%%
ZLineToT12NormLengthAtOptimalFiberLength = ...
  sarcomereProperties.ZLineToT12NormLengthAtOptimalFiberLength;

IGDTotalNormLengthAtOptimalFiberLength = ...
  sarcomereProperties.IGDTotalNormLengthAtOptimalFiberLength;

IGDFixedNormLengthAtOptimalFiberLength=...
    sarcomereProperties.IGDFixedNormLengthAtOptimalFiberLength;  


lceZero = fiberForceLengthCurve.xEnd(1,1);

k = size(fiberForceLengthCurve.ypts,2);
x0 = 0;
if(   fiberForceLengthCurve.ypts(end,k) < 1 )
  x0 =   fiberForceLengthCurve.xEnd(1,2)...
       + diff(fiberForceLengthCurve.xEnd)*0.1;
else
  x0 = mean(fiberForceLengthCurve.xpts(:,k));
end


fpeNRef = 0.5*fiberForceLengthCurve.yEnd(1,2);

%20 August 2023
%At lengths longer than lceRef the fpe and titin curves must be 
%approximately linear AND all of the titin segments must be well below
%their respective contour lengths. I have had to adjust fpeNRef from 
%a value of 1.0 to accomodate the rabbit EDL from Siebert et al. 2015
%which has a right-shifted force-length curve and yet is quite stiff
lceRef = ...
  calcBezierFcnXGivenY(fpeNRef, fiberForceLengthCurve, x0);

lceZeroHalf  = 0.5*lceZero;
lceRefHalf   = 0.5*lceRef;

kpeRef = calcBezierYFcnXDerivative(lceRef,...
                      fiberForceLengthCurve,...
                      1);

kpeRefHalf = 2*kpeRef;
kecmRefHalf= calcBezierYFcnXDerivative(lceRefHalf,...
                      forceLengthECMHalfCurve,...
                      1);

kTitinRefHalf = kpeRefHalf - kecmRefHalf;

igpStretchRate  = sarcomereProperties.IGPNormStretchRate;
pevkStretchRate = sarcomereProperties.PEVKNormStretchRate;
igdStretchRate  = sarcomereProperties.IGDFreeNormStretchRate;

igpContourLength    = sarcomereProperties.IGPContourLengthNorm;
pevkContourLength   = sarcomereProperties.PEVKContourLengthNorm;
igdContourLength    = sarcomereProperties.IGDFreeContourLengthNorm;

pevkIgdStretchRate = 0;
distalStretchRate  =nan;   % From the pevk-actin attachment point to myosin
proximalStretchRate=nan; % From the z-line to the pevk-actin attachment point



proximalContourLength=nan;
distalContourLength = nan;

switch flag_activeTitinModel

    case 0
        %Sticky spring: lump IgD and part of PEVK distal to attachment point 
        %Lump IgD with PEVK
        u = flag_useElasticIgD;
        assert(u==0 || u==1,'flag_useElasticIgD must be 0 or 1');

%        if(flag_useElasticIgD==1)
            pevkIgdStretchRate = sarcomereProperties.PEVKNormStretchRate ...
                                +u*sarcomereProperties.IGDFreeNormStretchRate;

            if(flag_solveForDefaultTwoSegmentTitinParameters==1)
                distalStretchRate = ...
                   (1-normPevkToActinAttachmentPoint)*sarcomereProperties.PEVKNormStretchRate ...
                                   + u*sarcomereProperties.IGDFreeNormStretchRate;  
                
                proximalStretchRate = sarcomereProperties.IGPNormStretchRate ...
                 + normPevkToActinAttachmentPoint*sarcomereProperties.PEVKNormStretchRate;  
            end
        
            proximalContourLength = sarcomereProperties.IGPContourLengthNorm ...
              + normPevkToActinAttachmentPoint*sarcomereProperties.PEVKContourLengthNorm;
            distalContourLength   = ...
                (1-normPevkToActinAttachmentPoint)*sarcomereProperties.PEVKContourLengthNorm ...
                +u*sarcomereProperties.IGDFreeContourLengthNorm;


    case 1 
        %Stiff spring: lump IgP and IgD together
        %Lump IgD with IgP 
        u = flag_useElasticIgD;
        assert(u==0 || u==1,'flag_useElasticIgD must be 0 or 1');

        if(flag_solveForDefaultTwoSegmentTitinParameters==1)
            proximalStretchRate = sarcomereProperties.IGPNormStretchRate;               
        end
    
        pevkIgdStretchRate = sarcomereProperties.PEVKNormStretchRate ...
                            + u*sarcomereProperties.IGDFreeNormStretchRate;  
        
        %For this model the distal stretch rate is identical to the
        %pevkIgdStretchRate
        %distalStretchRate = pevkIgdStretchRate;

        proximalContourLength = sarcomereProperties.IGPContourLengthNorm;
        distalContourLength   = sarcomereProperties.PEVKContourLengthNorm ...
                              + u*sarcomereProperties.IGDFreeContourLengthNorm;  
    otherwise
        assert(0,'flag_activeTitinModel must be 0 or 1');  

end




%%
% ka = kigp
% kb = kpevk
% kc = kigd
% kd = ktitin
% 1/ka + 1/kb + 1/kc = 1/kd [1]
%
% We also have the stretch rates extracted from Trombitas 1998 (see
% parameters/felineSoleus/getMammalianSkeletalMuscleNormalizedSarcomereProperties.m
% where the variable 'normStretchRateIgP is defined (near line 218-220)
%
% sa = rate the igp region stretches as the sarcomere stretches
% sb = rate the pevk region stretches as the sarcomere stretches
% sc = rate the igd region stretches as the sarcomere stretches
%
% Or more concisely
%
%  sa = delta la /delta ls     [2]
%  sb = delta lb /delta ls     [3]
%  sb = delta lc /delta ls     [4]
%
%
% where ls is the sarcomere length. Since these elements are in series
%
% ka = delta f / delta la  =  delta f / (delta sa * delta ls)   [5]
% kb = delta f / delta lb  =  delta f / (delta sb * delta ls)   [6]
% kc = delta f / delta lc  =  delta f / (delta sc * delta ls)   [7]
%
% If we multiply Eqn. 1 by ka we end up with
%
% ka/ka + ka/kb + ka/kc = ka/kd [8]
%
% Subsituting in Eqns. 5, 6, 7 on the left hand side
%
% 1 + lb/la + lc/la = ka/kd [9]
%
% Allowing us to solve for ka, since it is the only unknown in Eqn. 9
%
%%
sigp = igpStretchRate;
spevk= pevkStretchRate;
sigd = igdStretchRate;

kigp  = (     1       + (spevk/sigp) + (sigd/sigp))*kTitinRefHalf;
kpevk = ((sigp/spevk) +       1      + (sigd/spevk))*kTitinRefHalf;
kigd  = ((sigp/sigd)  + (spevk/sigd) +      1      )*kTitinRefHalf;

kerr = (1/kigp) + (1/kpevk) + (1/kigd) - (1/kTitinRefHalf);
assert(abs(kerr) < 1e-3);

A   = nan;
kD  = nan;
kP  = nan;
kDLow=nan;
kPLow=nan;
kDZero=nan;
kPZero=nan;

if(flag_solveForDefaultTwoSegmentTitinParameters==1)
    A   = distalStretchRate/proximalStretchRate;
    kD  = kTitinRefHalf*(A+1)/A;
    kP  = A*kD;

    
    %Geometrically scale the stiffnesses of the two segment titin
    %force-length curves
    kDLow     = kD*(forceLengthCurveSettings.kLow ...
                   /forceLengthCurveSettings.kToe);
    kDLow     = kDLow * scaleDKLow;

    kPLow     = kP*(forceLengthCurveSettings.kLow ...
                   /forceLengthCurveSettings.kToe);
    kPLow     = kPLow*scalePKLow;
    
    kDZero    = kD*(forceLengthCurveSettings.kZero ...
                   /forceLengthCurveSettings.kToe);

    if(useBigKDZero==1)
        kDZero = kDLow/10;
    end
    
    kPZero    = kP*(forceLengthCurveSettings.kZero ...
                   /forceLengthCurveSettings.kToe);  
    if(useBigKPZero==1)
        kPZero     = kPLow/10;
    end
    
end





%Geometrically scale the stiffnesses of the three segment titin
%force-length curves
kpevkLow    = kpevk*(forceLengthCurveSettings.kLow ...
                 /forceLengthCurveSettings.kToe);
kpevkLow    = kpevkLow*scalePevkKLow;

kigpLow     = kigp*(forceLengthCurveSettings.kLow ...
                   /forceLengthCurveSettings.kToe);
kigpLow     = kigpLow*scaleIgKLow;

kigdLow     = kigd*(forceLengthCurveSettings.kLow ...
                   /forceLengthCurveSettings.kToe);
kigdLow     = kigdLow*scaleIgKLow;

kpevkZero   = kpevk*(forceLengthCurveSettings.kZero ...
                  /forceLengthCurveSettings.kToe);

if(useBigPevkZero==1)
    kpevkZero = kpevkLow/20;
end

kigpZero    = kigp*(forceLengthCurveSettings.kZero ...
                    /forceLengthCurveSettings.kToe);  

kigdZero    = kigd*(forceLengthCurveSettings.kZero ...
                    /forceLengthCurveSettings.kToe);                    
if(useBigIgKZero==1)
    kigpZero = kigpLow/20;
    kigdZero = kigdLow/20;
end


%Evalute the normalized length of each element at lceRefHalf
%sarcomereProperties
ltitinRefHalf = 0;

if(flag_useElasticIgD==1)

    ltitinRefHalf = lceRefHalf...
      -(IGDFixedNormLengthAtOptimalFiberLength ...
      + ZLineToT12NormLengthAtOptimalFiberLength);  

else  
  ltitinRefHalf = lceRefHalf...
    -(IGDTotalNormLengthAtOptimalFiberLength ...
    + ZLineToT12NormLengthAtOptimalFiberLength);    
end

lPRefHalf  = nan; 
lDRefHalf  = nan;

if(flag_solveForDefaultTwoSegmentTitinParameters==1)
    lPRefHalf  = ltitinRefHalf /(1 + (kP/kD)); 
    lDRefHalf  = ltitinRefHalf /(1 + (kD/kP));
end

%As before
ligpRefHalfDefault  = ltitinRefHalf /(1 + (kigp/kpevk) + (kigp/kigd)); 
lpevkRefHalfDefault = ltitinRefHalf /((kpevk/kigp) + 1 + (kpevk/kigd));
ligdRefHalfDefault  = ltitinRefHalf /((kigd/kigp)  + (kigd/kpevk) + 1); 

lerr = (ligpRefHalfDefault+lpevkRefHalfDefault+ligdRefHalfDefault)-ltitinRefHalf;
assert(abs(lerr)<1e-3);


%Evaluate the proportion of the force-length curve that is of low 
%strain
strainWidth = forceLengthCurveSettings.normLengthToe-forceLengthCurveSettings.normLengthZero;  
lowStrainWidth =  (strainWidth - (1/forceLengthCurveSettings.kToe))...
                  /(1/forceLengthCurveSettings.kToe);
eZeroTest = forceLengthCurveSettings.normLengthToe ...
           -(1/forceLengthCurveSettings.kToe)...
           -(1/forceLengthCurveSettings.kToe)*lowStrainWidth;    

%Set the low strain values for each of the igp and pevk-igd to preserve
%this same proportion


fNTitinRef = (1-lambdaECM)*fpeNRef;



ligpZeroHalfDefault     = ligpRefHalfDefault      - (fNTitinRef/kigp) ...
                        - (fNTitinRef/kigp)*lowStrainWidth; 
lpevkZeroHalfDefault    = lpevkRefHalfDefault  - (fNTitinRef/kpevk) ...
                        - (fNTitinRef/kpevk)*lowStrainWidth;  
ligdZeroHalfDefault     = ligdRefHalfDefault      - (fNTitinRef/kigd) ...
                        - (fNTitinRef/kigd)*lowStrainWidth; 

%
% Remove some slack from the pevk
%

lpevkZeroHalfShort = 0;
lpevkRefHalfShort  = (fNTitinRef/kpevk);

lpevkZeroHalf = lpevkZeroHalfShort*(1-pevkDefaultBlendingVariable) ...
               +lpevkZeroHalfDefault*pevkDefaultBlendingVariable;

lpevkRefHalf = lpevkRefHalfShort*(1-pevkDefaultBlendingVariable) ...
               +lpevkRefHalfDefault*pevkDefaultBlendingVariable;

lpevkSlackTransfer = lpevkZeroHalfDefault-lpevkZeroHalf;

%%
% Remove some slack from the Ig segments
%%

igpAtOptLen = sarcomereProperties.IGPNormLengthAtOptimalFiberLength;
igdAtOptLen = sarcomereProperties.IGDFreeNormLengthAtOptimalFiberLength;

ligpSlackTransfer = lpevkSlackTransfer*igpAtOptLen/(igpAtOptLen + igdAtOptLen);
ligdSlackTransfer = lpevkSlackTransfer*igdAtOptLen/(igpAtOptLen + igdAtOptLen);


ligpZeroHalfShort = 0;
ligpRefHalfShort  = (fNTitinRef/kigp);

ligpZeroHalf = ligpZeroHalfShort*(1-igDefaultBlendingVariable) ...
               +ligpZeroHalfDefault*igDefaultBlendingVariable ...
               +ligpSlackTransfer;

ligpRefHalf = ligpRefHalfShort*(1-igDefaultBlendingVariable) ...
               +ligpRefHalfDefault*igDefaultBlendingVariable ...
               + ligpSlackTransfer;

ligdZeroHalfShort = 0;
ligdRefHalfShort  = (fNTitinRef/kigd);

ligdZeroHalf = ligdZeroHalfShort*(1-igDefaultBlendingVariable) ...
               +ligdZeroHalfDefault*igDefaultBlendingVariable ...
               +ligdSlackTransfer;

ligdRefHalf = ligdRefHalfShort*(1-igDefaultBlendingVariable) ...
               +ligdRefHalfDefault*igDefaultBlendingVariable ...
               + ligdSlackTransfer;


ligpZeroHalfShort = 0;
ligpRefHalfShort  = (fNTitinRef/kigp);





lPZeroHalf=nan;
lDZeroHalf=nan;
if(flag_solveForDefaultTwoSegmentTitinParameters==1)
    lPZeroHalf      = lPRefHalf      - (fNTitinRef/kP) ...
                     - (fNTitinRef/kP)*lowStrainWidth; 
    lDZeroHalf      = lDRefHalf  - (fNTitinRef/kD) ...
                     - (fNTitinRef/kD)*lowStrainWidth;  
end

%%
% Evaluate the zero, one, kzero, klow, and k values for two segments:
%   1. From the Z-line, through the IgP segment, to the desired PEVK segment fraction
%   2. From the desired PEVK segment fraction to the distal Ig/myosin boundary.
%%
pCurviness = (igCurviness*ligpRefHalf ...
            + pevkCurviness*lpevkRefHalf*normPevkToActinAttachmentPoint) ...
             /(ligpRefHalf+lpevkRefHalf*normPevkToActinAttachmentPoint);

dCurviness = (igCurviness*ligdRefHalf ...
            + pevkCurviness*lpevkRefHalf*(1-normPevkToActinAttachmentPoint)) ...
            /(ligdRefHalf + lpevkRefHalf*(1-normPevkToActinAttachmentPoint));

fNfailure = sarcomereProperties.normTitinFailureForce*2; 

%%
% Make the Igp curve
%%



if flag_createTwoSidedCurves == 0
  forceLengthIgPTitinCurve  = ...
    createWLCForceLengthCurve2025(ligpZeroHalf,...
                                ligpRefHalf,...
                                fNTitinRef,...
                                igpContourLength,...
                                fNfailure,...
                                figpZero,...
                                kigpZero,...
                                kigpLow,...
                                kigp,...
                                igCurviness,...
                                flag_computeCurveIntegrals,...
                                flag_useWLCTitinModel,...                                
                                muscleName,...
                                flag_useOctave); 
else
  forceLengthIgPTitinCurve  = ...
    createTwoSidedWLCForceLengthCurve2022(ligpZeroHalf,...
                                ligpRefHalf,...
                                fNTitinRef,...
                                igpContourLength,...
                                fNfailure,...
                                figpZero,...
                                kigpZero,...
                                kigpLow,...
                                kigp,...
                                igCurviness,...
                                flag_computeCurveIntegrals,...
                                flag_useWLCTitinModel,...
                                muscleName,...
                                flag_useOctave); 
end

forceLengthIgPTitinCurve.name = sprintf('%s.%s',...
  muscleName,'forceLengthIgPTitinCurve');


forceLengthIgPInverseTitinCurve = ...
      createInverseCurve(forceLengthIgPTitinCurve); 


%%
% Make the PEVK curve
%%

if flag_createTwoSidedCurves == 0

  forceLengthPevkTitinCurve  = ...
    createWLCForceLengthCurve2025(lpevkZeroHalf,...
                                lpevkRefHalf,...
                                fNTitinRef,...
                                pevkContourLength,...
                                fNfailure,...
                                fpevkZero,...
                                kpevkZero,...
                                kpevkLow,...
                                kpevk,...
                                pevkCurviness,...
                                flag_computeCurveIntegrals,...
                                flag_useWLCTitinModel,...
                                muscleName,...
                                flag_useOctave); 
else
  forceLengthPevkTitinCurve  = ...
    createTwoSidedWLCForceLengthCurve2022(lpevkZeroHalf,...
                                lpevkRefHalf,...
                                fNTitinRef,...
                                pevkContourLength,...
                                fNfailure,...
                                fpevkZero,...
                                kpevkZero,...
                                kpevkLow,...
                                kpevk,...
                                titinCurviness,...
                                flag_computeCurveIntegrals,...
                                flag_useWLCTitinModel,...
                                muscleName,...
                                flag_useOctave);
end

forceLengthPevkTitinCurve.name = sprintf('%s.%s',...
  muscleName,'forceLengthPevkTitinCurve');

forceLengthPevkInverseTitinCurve = ...
      createInverseCurve(forceLengthPevkTitinCurve); 

%%
% Make the Igd curve
%%

if flag_createTwoSidedCurves == 0
  forceLengthIgDTitinCurve  = ...
    createWLCForceLengthCurve2025(ligdZeroHalf,...
                                ligdRefHalf,...
                                fNTitinRef,...
                                igdContourLength,...
                                fNfailure,...
                                figdZero,...
                                kigdZero,...
                                kigdLow,...
                                kigd,...
                                igCurviness,...
                                flag_computeCurveIntegrals,...
                                flag_useWLCTitinModel,...
                                muscleName,...
                                flag_useOctave); 
else
  forceLengthIgDTitinCurve  = ...
    createTwoSidedWLCForceLengthCurve2022(ligdZeroHalf,...
                                ligdRefHalf,...
                                fNTitinRef,...
                                igdContourLength,...
                                fNfailure,...
                                figdZero,...
                                kigdZero,...
                                kigdLow,...
                                kigd,...
                                igCurviness,...
                                flag_computeCurveIntegrals,...
                                flag_useWLCTitinModel,...
                                muscleName,...
                                flag_useOctave); 
end

forceLengthIgDTitinCurve.name = sprintf('%s.%s',...
  muscleName,'forceLengthIgDTitinCurve');

forceLengthIgDInverseTitinCurve = ...
      createInverseCurve(forceLengthIgDTitinCurve); 


%%
%
% Make the P and D curves
%
%%

%%
% Make the P curve
%%
if flag_createTwoSidedCurves == 0
  forceLengthProximalTitinCurve  = ...
    createWLCForceLengthCurve2025(lPZeroHalf,...
                                lPRefHalf,...
                                fNTitinRef,...
                                proximalContourLength,...
                                fNfailure,...
                                fPZero,...
                                kPZero,...
                                kPLow,...
                                kP,...
                                pCurviness,...
                                flag_computeCurveIntegrals,...
                                flag_useWLCTitinModel,...
                                muscleName,...
                                flag_useOctave); 
else
  forceLengthProximalTitinCurve  = ...
    createTwoSidedWLCForceLengthCurve2022(lPZeroHalf,...
                                lPRefHalf,...
                                fNTitinRef,...
                                proximalContourLength,...
                                fNfailure,...
                                fPZero,...
                                kPZero,...
                                kPLow,...
                                kP,...
                                pCurviness,...
                                flag_computeCurveIntegrals,...
                                flag_useWLCTitinModel,...
                                muscleName,...
                                flag_useOctave); 
end


forceLengthProximalTitinCurve.name = sprintf('%s.%s',...
  muscleName,'forceLengthProximalTitinCurve');


forceLengthProximalTitinInverseCurve = ...
      createInverseCurve(forceLengthProximalTitinCurve); 



%%
% Make the D curve
%%
if flag_createTwoSidedCurves == 0
  forceLengthDistalTitinCurve  = ...
    createWLCForceLengthCurve2025(lDZeroHalf,...
                                lDRefHalf,...
                                fNTitinRef,...
                                distalContourLength,...
                                fNfailure,...
                                fDZero,...
                                kDZero,...
                                kDLow,...
                                kD,...
                                dCurviness,...
                                flag_computeCurveIntegrals,...
                                flag_useWLCTitinModel,...
                                muscleName,...
                                flag_useOctave);  
else 
  forceLengthDistalTitinCurve  = ...
    createTwoSidedWLCForceLengthCurve2022(lDZeroHalf,...
                                lDRefHalf,...
                                fNTitinRef,...
                                distalContourLength,...
                                fNfailure,...
                                fDZero,...
                                kDZero,...
                                kDLow,...
                                kD,...
                                dCurviness,...
                                flag_computeCurveIntegrals,...
                                flag_useWLCTitinModel,...
                                muscleName,...
                                flag_useOctave);    
end


forceLengthDistalTitinCurve.name = sprintf('%s.%s',...
  muscleName,'forceLengthDistalTitinCurve');

forceLengthDistalTitinInverseCurve = ...
      createInverseCurve(forceLengthDistalTitinCurve); 